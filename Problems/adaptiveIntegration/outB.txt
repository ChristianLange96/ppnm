Part B

Calculating integral of 1/Sqrt(x) dx from 0 to 1 with Clenshaw-Curtis transformaiton
The result is 1.99999, with 16 recursive calls to the function
The analytical result is 2.000 so this is almost a perfect match
Calculating integral of 1/Sqrt(x) dx from 0 to 1 without Clenshaw-Curtis transformation
The result is 1.99996, with 8572 recursive calls to the function
So the transformation is indeed recudcing the number of calls significantly

Calculating integral of ln(x)/Sqrt(x) dx from 0 to 1 with Clenshaw-Curtis transformaiton
The result is -3.99987, with 96 recursive calls to the function
The analytical result is -4.000 so this is almost a perfect match
Calculating integral of ln(x)/Sqrt(x) dx from 0 to 1 without Clenshaw-Curtis transformaiton
The result is -3.99992, with 8604 recursive calls to the function
So again the transformation is indeed recudcing the number of calls significantly

Calculating integral of 4 * Sqrt(1-x^2) dx from 0 to 1 with Clenshaw-Curtis transformaiton
The result is 3.1415763865, with 44 recursive calls to the function
The analytical result is PI for comparison
Calculating integral of 4 * Sqrt(1-x^2) dx from 0 to 1 without Clenshaw-Curtis transformaiton
The result is 3.1418345780, with 28 recursive calls to the function
So the transformation get a numerical result closer to PI than without but also uses more recursive calls
This is properly due to the fact that the integral has no singularity, which is where the transformation outruns the normal method.
Comparing to the 'o8av' integrator routine from matlib
The result is 3.1413229434, with 8 recursive calls to the function
So 'o8av' is much faster in terms of calls but not as accurate - but that can be improved by adjusting acc and eps, of course.
